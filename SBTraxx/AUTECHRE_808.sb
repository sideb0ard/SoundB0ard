# Autechre-style Beat with TR-808 Drum Synth
# Complex polyrhythms, glitchy percussion, micro-timing variations
# Using drum synth notes: 0=kick, 1=snare, 2=ch, 3=clap, 4=oh, 5-7=FM, 8=lazer

# Create drum synth and load AUTECHRE preset (glitchy, digital, experimental)
let drums = drum();
load_preset(drums, "AUTECHRE");

# MIDI Note mapping:
# 0 = Bass Drum (bd)
# 1 = Snare Drum (sd)
# 2 = Closed Hi-Hat (hh)
# 3 = Hand Clap (cp)
# 4 = Open Hi-Hat (hh2)
# 5 = FM Drum 1
# 6 = FM Drum 2
# 7 = FM Drum 3
# 8 = Lazer

# Kick drum component with variations
let kick_comp = comp()
{
  setup()
  {
    # Multiple kick patterns for variation
    let k1 = [1, 0, 0, 0,  0, 0, 1, 0,  0, 0, 0, 0,  0, 1, 0, 0];
    let k2 = [1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, 0, 0];
    let k3 = [1, 0, 1, 0,  0, 0, 0, 0,  1, 0, 0, 0,  0, 0, 1, 0];
    let k4 = [0, 0, 0, 1,  0, 0, 1, 0,  0, 1, 0, 0,  1, 0, 0, 0];

    # Timing offsets for micro-timing (Autechre-style)
    let offsets = [0, 15, -12, 8, -20, 25, -8, 10];
    let ox = 0;

    # Velocity variations
    let vels = [90, 100, 80, 110, 95, 85];
    let vx = 0;
  }
  run()
  {
    let kpat = k1;

    # Pattern selection based on count
    if (count % 4 == 1) {
      kpat = k2;
    }
    if (count % 7 == 5) {
      kpat = k3;
    }
    if (count % 11 == 3) {
      kpat = k4;
    }

    for (let i = 0; i < 16; i++) {
      if (kpat[i] == 1) {
        # Add micro-timing offsets for groove
        let offset = offsets[ox];
        ox = incr(ox, 0, len(offsets));

        # Note 0 = Bass Drum
        note_on_at(drums, 0, i * pp + offset, vel = vels[vx]);
        vx = incr(vx, 0, len(vels));
      }
    }
  }
}

# Snare/clap pattern with complex rhythm
let snare_comp = comp()
{
  setup()
  {
    let s1 = [0, 0, 0, 0,  1, 0, 0, 0,  0, 0, 0, 0,  1, 0, 0, 0];
    let s2 = [0, 0, 0, 0,  1, 0, 0, 1,  0, 0, 0, 0,  1, 0, 1, 0];
    let s3 = [0, 0, 1, 0,  1, 0, 0, 0,  0, 1, 0, 0,  1, 0, 0, 1];

    let clap_pats = [
      [0, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, 0, 1],
      [0, 0, 0, 1,  0, 0, 1, 0,  0, 1, 0, 0,  0, 0, 0, 0]
    ];
      let cx = 0;
  }
  run()
  {
    let spat = s1;
    if (count % 3 == 2) {
      spat = s2;
    }
    if (count % 8 == 7) {
      spat = s3;
    }

    for (let i = 0; i < 16; i++) {
      if (spat[i] == 1) {
        # Note 1 = Snare Drum
        note_on_at(drums, 1, i * pp, vel = 80 + rand(40));
      }
    }

    # Clap layer
    if (count % 2 == 1) {
      let cpat = clap_pats[cx];
      for (let i = 0; i < 16; i++) {
        if (cpat[i] == 1) {
          # Note 3 = Hand Clap
          note_on_at(drums, 3, i * pp + 20, vel = 50 + rand(30));
        }
      }
      cx = incr(cx, 0, len(clap_pats));
    }
  }
}

# Hi-hat patterns with open/closed variations
let hats_comp = comp()
{
  setup()
  {
    let h1 = [1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0];
    let h2 = [1, 1, 0, 1,  0, 1, 1, 0,  1, 0, 1, 1,  0, 1, 0, 1];
    let h3 = [1, 0, 0, 1,  1, 1, 0, 0,  1, 0, 1, 0,  0, 1, 1, 1];

    # Open hat pattern
    let oh1 = [0, 0, 0, 0,  0, 0, 0, 1,  0, 0, 0, 0,  0, 0, 0, 1];
  }
  run()
  {
    if (count % 8 < 6) {
      let hpat = h1;
      if (count % 4 == 2) {
        hpat = h2;
      }
      if (count % 6 == 5) {
        hpat = h3;
      }

      for (let i = 0; i < 16; i++) {
        if (hpat[i] == 1) {
          # Micro timing
          let offset = 0;
          if (i % 2 == 1) {
            offset = 15;
          }

          # Note 2 = Closed Hi-Hat
          note_on_at(drums, 2, i * pp + offset, vel = 30 + rand(40));
        }

        # Open hats on specific beats
        if (oh1[i] == 1) {
          # Note 4 = Open Hi-Hat
          note_on_at(drums, 4, i * pp, vel = 50 + rand(30));
        }
      }
    }
  }
}

# Glitchy FM percussion - POLYRHYTHMIC MADNESS!
let glitch_fm_comp = comp()
{
  setup()
  {
    # POLYRHYTHMIC PATTERNS - different lengths cycling against 16-step grid
    let poly7 = [1, 0, 1, 0, 1, 1, 0];
    let poly5 = [1, 0, 1, 1, 0];
    let poly13 = [1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0];
    let poly9 = [1, 0, 0, 1, 1, 0, 1, 0, 1];
  }
  run()
  {
    # Layer 1: FM1 with 7-step polyrhythm
    for (let i = 0; i < 16; i++) {
      let idx = i % len(poly7);
      if (poly7[idx] == 1) {
        let offset = rand(50) - 25;
        # Note 5 = FM Drum 1
        note_on_at(drums, 5, i * pp + offset, vel = 40 + rand(60));
      }
    }

    # Layer 2: FM2 with 5-step polyrhythm (only every other bar)
    if (count % 2 == 0) {
      for (let i = 0; i < 16; i++) {
        let idx = i % len(poly5);
        if (poly5[idx] == 1) {
          let offset = rand(40) - 20;
          # Note 6 = FM Drum 2
          note_on_at(drums, 6, i * pp + offset, vel = 50 + rand(50));
        }
      }
    }

    # Layer 3: FM3 with 13-step polyrhythm (sparse)
    if (count % 4 < 3) {
      for (let i = 0; i < 16; i++) {
        let idx = i % len(poly13);
        if (poly13[idx] == 1) {
          let offset = rand(60) - 30;
          # Note 7 = FM Drum 3
          note_on_at(drums, 7, i * pp + offset, vel = 30 + rand(70));
        }
      }
    }

    # Layer 4: Lazer glitches with 9-step polyrhythm
    if (count % 3 == 2) {
      for (let i = 0; i < 16; i++) {
        let idx = i % len(poly9);
        if (poly9[idx] == 1) {
          # Note 8 = Lazer
          note_on_at(drums, 8, i * pp + rand(30), vel = 20 + rand(80));
        }
      }
    }
  }
}

# Master arrangement
let main_comp = comp()
{
  setup()
  {
    let c = 0;
  }
  run()
  {
    # Build up arrangement
    if (c == 0) {
      p31 # kick_comp;
    }
    if (c == 4) {
      p32 # snare_comp;
    }
    if (c == 8) {
      p33 # glitch_fm_comp;
    }
    if (c == 12) {
      p34 # hats_comp;
    }
    if (c == 16) {
      # Drop hats
      p34 # "";
    }
    if (c == 20) {
      p34 # hats_comp;
    }
    if (c == 24) {
      # Breakdown
      p31 # "";
      p32 # "";
    }
    if (c == 28) {
      # Build back
      p31 # kick_comp;
    }
    if (c == 30) {
      p32 # snare_comp;
    }
    if (c == 32) {
      # Full power with all elements
      p31 # kick_comp;
      p32 # snare_comp;
      p33 # glitch_fm_comp;
      p34 # hats_comp;
    }

    print("Bar:", c);
    c++;
  }
}
