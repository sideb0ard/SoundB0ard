# Using drum synth notes: 0=kick, 1=snare, 2=clap, 3=ch, 4=oh, 5-7=FM, 8=lazer

let init = fn()
{
  load_preset(sbdrum, "glitchhh808");
  load_preset(dx2, "LOWES");
  bpm 110;
}

# MIDI Note mapping:
# 0 = Bass Drum (bd)
# 1 = Snare Drum (sd)
# 2 = Hand Clap (cp)
# 3 = Closed Hi-Hat (hh)
# 4 = Open Hi-Hat (hh2)
# 5 = FM Drum 1
# 6 = FM Drum 2
# 7 = FM Drum 3
# 8 = Lazer

let kick_comp = comp()
{
  setup()
  {
    let k1 = [1, 0, 0, 0,  0, 0, 1, 0,  0, 0, 0, 0,  0, 1, 0, 0];
    let k2 = [1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, 0, 0];
    let k3 = [1, 0, 1, 0,  0, 0, 0, 0,  1, 0, 0, 0,  0, 0, 1, 0];
    let k4 = [0, 0, 0, 1,  0, 0, 1, 0,  0, 1, 0, 0,  1, 0, 0, 0];

    # Timing offsets for micro-timing
    let offsets = [0, 15, -12, 8, -20, 25, -8, 10];
    let ox = 0;

    # Velocity variations
    let vels = [90, 100, 80, 110, 95, 85];
    let vx = 0;
  }
  run()
  {
    let kpat = k1;

    # Pattern selection based on count
    if (count % 4 == 1) {
      kpat = k2;
    }
    if (count % 7 == 5) {
      kpat = k3;
    }
    if (count % 11 == 3) {
      kpat = k4;
    }

    for (let i = 0; i < 16; i++) {
      if (kpat[i] == 1) {
        # Add micro-timing offsets for groove
        let offset = offsets[ox];
        ox = incr(ox, 0, len(offsets));

        # Note 0 = Bass Drum
        note_on_at(sbdrum, 0, i * pp + offset, vel = vels[vx]);
        vx = incr(vx, 0, len(vels));
      }
    }
  }
}

# Snare/clap pattern with complex rhythm
let snare_comp = comp()
{
  setup()
  {
    let s1 = [0, 0, 0, 0,  1, 0, 0, 0,  0, 0, 0, 0,  1, 0, 0, 0];
    let s2 = [0, 0, 0, 0,  1, 0, 0, 1,  0, 0, 0, 0,  1, 0, 1, 0];
    let s3 = [0, 0, 1, 0,  1, 0, 0, 0,  0, 1, 0, 0,  1, 0, 0, 1];

    let clap_pats = [
      [0, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, 0, 1],
      [0, 0, 0, 1,  0, 0, 1, 0,  0, 1, 0, 0,  0, 0, 0, 0]
    ];
      let cx = 0;
  }
  run()
  {
    let spat = s1;
    if (count % 3 == 2) {
      spat = s2;
    }
    if (count % 8 == 7) {
      spat = s3;
    }

    for (let i = 0; i < 16; i++) {
      if (spat[i] == 1) {
        note_on_at(sd, 1, i * pp, vel = 80 + rand(40));
      }
    }

    # Clap layer
    if (count % 2 == 1) {
      let cpat = clap_pats[cx];
      for (let i = 0; i < 16; i++) {
        if (cpat[i] == 1) {
          note_on_at(cp, 1, i * pp + 20, vel = 50 + rand(30));
        }
      }
      cx = incr(cx, 0, len(clap_pats));
    }
  }
}

# Hi-hat patterns with open/closed variations
let hats_comp = comp()
{
  setup()
  {
    let h1 = [1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0];
    let h2 = [1, 1, 0, 1,  0, 1, 1, 0,  1, 0, 1, 1,  0, 1, 0, 1];
    let h3 = [1, 0, 0, 1,  1, 1, 0, 0,  1, 0, 1, 0,  0, 1, 1, 1];

    # Open hat pattern
    let oh1 = [0, 0, 0, 0,  0, 0, 0, 1,  0, 0, 0, 0,  0, 0, 0, 1];
  }
  run()
  {
    if (count % 8 < 6) {
      let hpat = h1;
      if (count % 4 == 2) {
        hpat = h2;
      }
      if (count % 6 == 5) {
        hpat = h3;
      }

      for (let i = 0; i < 16; i++) {
        if (hpat[i] == 1) {
          # Micro timing
          let offset = 0;
          if (i % 2 == 1) {
            offset = 15;
          }

          # Note 2 = Closed Hi-Hat
          note_on_at(sbdrum, 3, i * pp + offset, vel = 30 + rand(40));
        }

        # Open hats on specific beats
        if (oh1[i] == 1) {
          # Note 4 = Open Hi-Hat
          note_on_at(sbdrum, 4, i * pp, vel = 50 + rand(30));
        }
      }
    }
  }
}

let glitch_fm_comp = comp()
{
  setup()
  {
    # POLYRHYTHMIC PATTERNS - different lengths cycling against 16-step grid
    let poly7 = [1, 0, 1, 0, 1, 1, 0];
    let poly5 = [1, 0, 1, 1, 0];
    let poly13 = [1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0];
    let poly9 = [1, 0, 0, 1, 1, 0, 1, 0, 1];

    let durz = [30, 50, 80, 110, 60, 150];
    let drx = 0;
  }
  run()
  {
    # Layer 1: FM1 with 7-step polyrhythm
    for (let i = 0; i < 16; i++) {
      let idx = i % len(poly7);
      if (poly7[idx] == 1) {
        let offset = rand(50) - 25;
        # Note 5 = FM Drum 1
        note_on_at(sbdrum, 5, i * pp + offset, vel = 40 + rand(60), dur = durz[drx]);
        drx = incr(drx, 0, len(durz));
      }
    }

    # Layer 2: FM2 with 5-step polyrhythm (only every other bar)
    if (count % 2 == 0) {
      for (let i = 0; i < 16; i++) {
        let idx = i % len(poly5);
        if (poly5[idx] == 1) {
          let offset = rand(40) - 20;
          # Note 6 = FM Drum 2
          note_on_at(sbdrum, 6, i * pp + offset, vel = 50 + rand(50), dur = durz[drx]);
          drx = incr(drx, 0, len(durz));
        }
      }
    }

    # Layer 3: FM3 with 13-step polyrhythm (sparse)
    if (count % 4 < 3) {
      for (let i = 0; i < 16; i++) {
        let idx = i % len(poly13);
        if (poly13[idx] == 1) {
          let offset = rand(60) - 30;
          # Note 7 = FM Drum 3
          note_on_at(sbdrum, 7, i * pp + offset, vel = 30 + rand(70), dur = durz[drx]);
          drx = incr(drx, 0, len(durz));
        }
      }
    }

    # Layer 4: Lazer glitches with 9-step polyrhythm
    if (count % 3 == 2) {
      for (let i = 0; i < 16; i++) {
        let idx = i % len(poly9);
        if (poly9[idx] == 1) {
          # Note 8 = Lazer
          note_on_at(sbdrum, 8, i * pp + rand(30), vel = 20 + rand(80), dur = durz[drx]);
          drx = incr(drx, 0, len(durz));
        }
      }
    }
  }
}

let dxrar = comp()
{
  setup()
  {
    let mel1 =  [0, 22, 0, 0,  0, 20, 0, 0,  0, 0, 27, 0,  25, 0, 0, 28];
    let mel2 =  [0, 32, 0, 20,  0, 22, 0, 0,  27, 28, 0, 0,  20, 0, 30, 32];
  }
  run()
  {
    let mel = mel1;
    if (count % 4 == 3) {
      mel = mel2;
    }
    for (let i = 0; i < 16; i++) {
      if (mel[i] > 0) {
        note_on_at(dx2, mel[i], i * pp, dur = 300);
      }
    }
  }
}

let DXnar = comp()
{
  setup()
  {
    let melorig = [49, 49, 0, 47,  51, 51, 0, 47,  54, 52, 0, 51,  56, 54, 51, 0];
  }
  run()
  {
    if (count % 2 == 1) {

      let mel = rotate(melorig, count % 7);
      if (count % 16 == 1) {
        mel = reverse(mel);
      }
      if (count % 12 == 1) {
        mel = shuffle(mel);
      }
      for (let i = 0; i < 16; i++) {
        let off = 40;
        if (i % 2 == 0) {
          off = 0;
        }
        if (mel[i] > 0) {
          note_on_at(dx3, mel[i], i * pp, dur = 40);
        }
      }
    }
  }
}



# Master arrangement
let main_comp = comp()
{
  setup()
  {
    let c = 0;
  }
  run()
  {
    # Build up arrangement
    if (c == 0) {
      p31 # kick_comp;
    }
    if (c == 4) {
      p32 # snare_comp;
    }
    if (c == 8) {
      p33 # glitch_fm_comp;
    }
    if (c == 12) {
      p34 # hats_comp;
    }
    if (c == 16) {
      # Drop hats
      p34 # "";
    }
    if (c == 20) {
      p34 # hats_comp;
    }
    if (c == 24) {
      # Breakdown
      p31 # "";
      p32 # "";
    }
    if (c == 28) {
      # Build back
      p31 # kick_comp;
    }
    if (c == 30) {
      p32 # snare_comp;
    }
    if (c == 32) {
      # Full power with all elements
      p31 # kick_comp;
      p32 # snare_comp;
      p33 # glitch_fm_comp;
      p34 # hats_comp;
    }

    # uncomment if you want to follow along
    # print("Bar:", c);
    c++;
  }
}
