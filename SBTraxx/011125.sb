# bpm 90
# load_preset(sbdrum, "HRF2");  load_preset(sb2, "MODrr");
# load_preset(dx, "SMMTH2"); load_preset(dx2, "DZT2");
# let dx3 = fm(); load_preset(dx3, "WURBKl");

let plblah_fn = fn(midi_num, pat)
{
  let inst = sb2;
  if (midi_num == 0) {
    inst = sbdrum;
  }
  for (let i = 0; i < 16; i++) {
    let v = 100 + rand(27);
    if (i % 4 == 0) {
      v = 127;
    }
    if (midi_num == 0) {
      v = 127;
    }
    let offset = -15;
    if (i % 2 == 0) {
      offset = 0;
    }
    if (pat[i] == 1) {
      note_on_at(inst, midi_num, i * pp + offset, vel = v);
    }
  }
}

# preset HARF
let dblah_gen = gen()
{
  setup()
  {
    let beatA = [1, 0, 0, 1,  0, 0, 1, 0,  0, 0, 1, 0,  0, 0, 0, 0];
    let snareA = [0, 0, 0, 0,  0, 0, 0, 0,  1, 0, 0, 0,  0, 0, 0, 0];
    let hatzA = [0, 1, 0, 1,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0];

    let beatB = [1, 0, 0, 1,  0, 1, 0, 0,  0, 1, 0, 0,  0, 0, 0, 0];
    let snareB = [0, 0, 0, 0,  0, 0, 0, 0,  1, 0, 0, 0,  0, 0, 0, 1];
    let hatzB = [0, 0, 1, 0,  1, 0, 0, 0,  0, 1, 1, 0,  1, 0, 1, 0];

    let beatC = [0, 0, 0, 0,  0, 0, 1, 0,  0, 1, 0, 0,  0, 0, 0, 0];
    let snareC = [0, 0, 0, 0,  0, 0, 0, 0,  1, 0, 0, 0,  0, 0, 0, 0];
    let hatzC = [1, 0, 1, 1,  1, 0, 1, 1,  1, 1, 0, 1,  1, 0, 1, 1];
    let cddecider = 0;

    let percz = rand_array(16, 0, 4);
  }
  run()
  {
    #let inbetweens = invert(beatA);
    let inbetweens = mask(percz, beatA);
    if (count % 2 == 0) {
      plblah_fn(0, beatA);
      plblah_fn(3, snareA);
      #plblah_fn(2, hatzA);
    } else {
      if (count % 4 == 1) {
        #inbetweens = invert(beatB);
        inbetweens = mask(percz, beatB);
        plblah_fn(0, beatB);
        plblah_fn(3, snareB);
        #plblah_fn(2, hatzA);
      } else {
        if (cddecider % 2 == 0) {
          #inbetweens = invert(beatC);
          inbetweens = mask(percz, beatC);
          plblah_fn(0, beatC);
          plblah_fn(3, snareC);
          plblah_fn(2, hatzC);
          #} else {
            #  dmbeat(sb2, 0);
            #  cmbeat(sb2, 3);
            #  plblah_fn(2, hatzC);
          }
        cddecider++;
      }
    }
    #print(inbetweens);

    for (let i = 0; i < 16; i++) {
      if (inbetweens[i] == 1) {
        note_on_at(grnr, 0, i * pp, dur = 300);
      }
      if (inbetweens[i] == 2) {
        note_on_at(sts, 0, i * pp, dur = 200);
      }
      if (inbetweens[i] == 3) {
        note_on_at(xen, 0, i * pp, dur = 200);
      }
      if (inbetweens[i] == 4) {
        note_on_at(betd, 0, i * pp, dur = 200);
      }
    }

    if (count % 4 == 3) {
      sched(0, 0, 97, 3840, "set sb2:cp_delay_feedback_pct %");
      sched(3840, 0, 0, 0, "set sb2:cp_delay_feedback_pct %");
    }
    if (count % 7 == 6) {
      sched(0, 50, 150, 3840*2, "set sb2:bd_decay %");
      sched(3840*2, 50, 50, 0, "set sb2:bd_decay %");
      percz = rand_array(16, 0, 5);
    }
  }
}

let key = 49;
# minor
let key_type = 1;

# argyarpG
# load_preset(dx, "SMMTH"); load_preset(dx2, "rrrsmth");
# dx simplePAINOUPDATE flurpE DATRZ2 // rrrsmth
let chblah_gen = gen()
{
  setup()
  {
    let notez = notes_in_key(key, key_type);
    # I V
    #let prog = [0, 0, 4, 5, 0, 4, 3];
    let prog = [0, 3, 4];
    let px = 0;
    let rhythm1 = [1, 0, 1, 0,  1, 0, 1, 0,  0, 0, 1, 0,  0, 1, 0, 0];
    let rhythm2 = [1, 0, 0, 1,  0, 1, 0, 1,  1, 0, 1, 0,  0, 1, 0, 1];
    let rhythm3 = [0, 0, 1, 1,  0, 0, 1, 1,  0, 0, 1, 0,  0, 1, 0, 1];
    let rhmz = [rhythm1, rhythm1, rhythm2];
    let rx = 0;
    let durz = [50, 100, 150, 200, 150];
    let drx = 0;

    let dnz = [0, 12, 24, 12];
    let dnx = 0;

    #let chrdmodz = [0, 0, 1, 2, 1];
    let chrdmodz = [0];
    let chx = 0;

    let attz = [100, 50, 200, 300, 430, 10];
    let ax = 0;
  }
  run()
  {
    let rhythm = rhmz[rx];
    rx = incr(rx, 0, len(rhmz));
    let chrd = down(notes_in_chord(notez[prog[px]], key, chrdmodz[chx], key_type), dnz[dnx]);

    set dx:e1att attz[ax];
    ax = incr(ax, 0, len(attz));

    chx = incr(chx, 0, len(chrdmodz));
    dnx = incr(dnx, 0, len(dnz));
    px = incr(px, 0, len(prog));
    for (let i = 0; i < 16; i++) {
      let v = 90 + rand(37);
      if (i % 4 == 0) {
        v = 127;
      }
      if (count % 2 == 1 && i == 12) {
        chrd = notes_in_chord(notez[prog[px]], key, 2, key_type);
      }
      if (rhythm[i] == 1) {
        note_on_at(dx, chrd, i * pp, dur = durz[drx], vel = v);
        drx = incr(drx, 0, len(durz));
      } else {
        if (count % 2 == 1) {
          note_on_at(dx2, chrd, i * pp, dur=durz[drx], vel = v);
        }
      }
    }
    if (count % 4 == 2) {
      sched(0, 20, 70, 3840*2, "set dx:op2out %");
      sched(3840*2, 70, 70, 0, "set dx:op2out %");
    }
  }
}

# dx3 SNURFz WURBKl
let melblah_gen = gen()
{
  setup()
  {
    let mel1 = [51, 0, 0, 57,  0, 0, 61, 0,  52, 0, 0, 56,  0, 51,0 , 49];
    let mel2 = [0, 0, 49, 0,  0, 56, 0, 0,  0, 0, 52, 56,  0, 0, 0, 49];
    let mel3 = [49, 56, 49, 56,  49, 56, 51, 49,  49, 56, 52, 56,  49, 0, 0, 49];
    let durz = [60, 340, 70, 640, 50];
    let drx = 0;
    let melz = [mel3, mel1, mel2, mel1, mel1, mel2, mel3];
    let melx = 0;
  }
  run()
  {
    let mel = down(melz[melx], 12);
    melx = incr(melx, 0, len(melz));
    if (count % 6 == 2) {
      mel = down(mel, 12);
    }
    for (let i = 0; i < 16; i++) {
      let v = 80 + rand(47);
      if (count % 4 == 2) {
        v = 127;
      }
      if (mel[i] > 0) {
        note_on_at(dx3, mel[i], i * pp, dur = durz[drx], vel = v);
        drx = incr(drx, 0, len(durz));
      }
    }
    if (count % 4 == 0) {
      sched(0, 60, 80, 3840 * 4, "set dx3:op2out %");
    }
    if (count % 9 == 0) {
      sched(0, 0.5, 17, 3840 * 3, "set dx3:l1_rate %");
      sched(3840 * 3, 7, 7, 0, "set dx3:l1_rate %");
    }
  }
}

