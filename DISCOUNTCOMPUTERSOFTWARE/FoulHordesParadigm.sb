# key f - 17, 29, 41, 53, 65, 77
let key = 27;
# [29, 31, 33, 34, 36, 38, 40, 41]
# vi-ii-V-I [38, 41, 45] [31, 34, 38] [36, 40, 43] [29, 33, 36]

# let chrdz = [ [38, 41, 45], [31, 34, 38], [36, 40, 43], [29, 33, 36] ];
# let chrdz = [ [38, 45], [34, 38], [43], [29, 36] ];
let chrdz = [ [36, 43], [29, 36], [38] ];
let crx = 0;
let ntx = 0;

let beat = rand_beat();

# bpm 160; load_preset(per2, "SNDCLNR")
# bpm 160; load_preset(per2, "FRAK")
# let bx = loop(dloops/brandyxmen2bar1.aif); set bx:len 2; p2 $ wblah_gen; p3 $ ddblah_gen

let wblah_gen = gen()
{
  setup() {
    let sw = 100;
    let dr = 50;
  }
  run()
  {
    if (count% 8 == 7) {
      set bx:scramble 1;
    }
    if (count% 16 == 15) {
      set bx:reverse 1;
    }
    if (count% 12 == 0) {
      set bx:stutter 1;
    }
  }
}

# dx2 = wururrrp
let ddblah_gen = gen()
{
  setup()
  {
    let d = 130;
    let mel1 = key_riff(key);
    let mel2 = key_riff(key);
    let mel3 = key_riff(key);
    let melz = [mel1, mel1, mel2];
    let mx = 0;
    let offr = 110;
    let ioff = 2;
  }
  run()
  {
    if (count % 4 < 3) {
      for (i = 0; i < 16; ++i) {
        let off = 0;
        if (i % 2 == 1) {
          off = offr;
        }
        if (melz[mx][i] > 0) {
          let v = 100 + rand(27);
          if (i % 4 == 1) {
            v = 127;
          }
          if (!is_in(beat, i)) {
            let n =  melz[mx][i];
            if (count % 8 == 7) {
              n = n + 12;
            }
            note_on_at(dx2, n, i * pp + off, dur = d);

            if (count % 4 == 0) {
              let fourth= scale_note(n + 7, key);
              note_on_at(dx2, fourth, i * pp + off, dur = d);
            }
          }
          d = d + 20;
        }
      }
      if (d > 400) {
        d = 100;
      }
      mx = incr(mx, 0, len(melz));
    }
    set bx:poffset 0;
    if (count % 3 == 0) {
      for (i = 0; i < 16; ++i) {
        if (beat[i] == 1) {
          set bx:pidx i;
        }
      }
    }

    if (count % 8 == 0) {
      beat = rand_beat();
      mel1 = key_riff(k);
      mel2 = key_riff(k);
      mel3 = key_riff(k);
      melz = [mel1, mel1, mel2];
    }
  }
}

# load_preset(oh, "OH"); p4 $ hhblah_gen
let hhblah_gen = gen()
{
  setup()
  {
    let hpat = rand_array(16, 0, 1);
    let offr = 10;
  }
  run()
  {
    for (i = 0; i < 16; ++i) {
      let off = 0;
      if (i % 2 == 1) {
        off = offr;
      }
      if (hpat[i] == 1) {
        note_on_at(hh, 17, i * pp + off);
      }
    }
    offr = offr + 10;
    if (offr > 160) {
      offr = 20;
    }
    if (count % 4 == 0) {
      hpat = rand_array(16, 0, 1);
    }
    vol bx 1;
    if (count % 16 == 15) {
      vol bx 0 at=12*pp;
    }
    for (i = 0; i < 16; ++i) {
      if (i % 4 == 0) {
        note_on_at(oh, 23, i * pp);
      }
    }
  }
}

# let vrv = loop(JUNALGOGZ/VIBErev.wav); set vrv:len 4; add_fx(vrv, "sidechain", bx);
# let nots = loop(voices/notstayinghome.wav); set nots:len 2; p6 $ vblah_gen
let vblah_gen = gen()
{
  setup()
  {
  }
  run()
  {

    unsolo();
    if (count % 2 == 0) {
      #vol nots 0.3;
      set vrv:scramble 1;
      set nots:stutter 1;
    }
    if (count % 8 == 7) {
      set vrv:reverse 1;
      vol nots 0;
      #solo(vrv, at=8*pp);
    }
    if (count % 4 == 0) {
      vol vrv 1;
    }
    if (count % 15 == 3) {
      solo(vrv, at=14*pp);
      vol vrv 0 at = 16*pp;
    }
  }
}
# dx -  default
# let snp = loop(Riser77/snipHop.wav); set snp:len 2; p4 $ dxxxblah_gen
let dxxxblah_gen = gen()
{
  setup()
  {
    let ix = 0;
    let mxx = 3;
    let dr = 100;
  }
  run()
  {
    let ch = down(chrdz[crx], 12);
    let be = combinor(beat, ch);
    if (count % 8 < 6) {
      for (i = 0; i < 16; ++i) {
        if (stepper(dx, be, ix, i, dr)) {
        } else {
          if (i > 8) {
            note_on_at(per2, ch, i * pp, dur = dr);
          }
        }
        ix = incr(ix, 0, mxx);
        dr = dr + 10;
        if (dr > 400) {
          dr = 77;
        }
      }
    }
    mxx = incr(mxx, 2, 16);
  }
}

let kkbelah_gen = gen()
{
  setup()
  {
  }
  run()
  {
    if (count % 4 == 0) {
      set snp:stutter 1;
    }
    if (count % 6 == 0) {
      set snp:scramble 1;
    }
    if (count % 16 == 15) {
      set snp:reverse 1;
    }
  }
}


let melblah_gen = gen()
{
  setup()
  {
  }
  run()
  {
  }
}

